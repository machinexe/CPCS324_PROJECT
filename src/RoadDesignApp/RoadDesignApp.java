package RoadDesignApp;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import GraphFramework.*;

/*
 *  @authors Fay, Aisha, Woroud
 * B9A
 * CPCS-324
 * Project Code
 * 19th Oct. 2022
 */

public class RoadDesignApp {


	public static void main(String[] args) throws FileNotFoundException {
		 //  ======================Main======================== //
        Scanner input = new Scanner(System.in);

        // Intilize variables
        int verticesNO = 0; // number of vertices
        int edgesNO = 0; // number of edges

        // ======================Header========================//
        System.out.println("\t\t--------------------------------------------------------------------\n"
        		+ "\t\t|Test to Compute the Minimum Spanning Tree and Compare Running Time|\n"
        		+ "\t\t|For Kruskal's Algorithm & Prim's Algorithm  (With Priority Queue) |\n"
        		+ "\t\t-------------------------------------------------------------------\n");

        System.out.println("\t\t**********  (1) Requirement 1 Using Read_from_Graph Func. ********** \n"
        		+ "\t\t**********  (2) Requirement 2 Using Make_Graph Func.      ********** \n");
        
        // ------- Read User Input for the Selected Requirement -------- //

        System.out.print("Select Requirement Option --> ");
        
        int userInput = input.nextInt(); // Option of the Requirement
   
    	// make sure user enter within option
        while ( userInput != 1 && userInput != 2) {
       	  System.out.println("Wrong Selection. ");
              System.out.print("Select Requirement Option -> ");
              userInput = input.nextInt(); 
          }
        
    	
        // ------------------------ Requirement 1 ------------------------ //
        
        if(userInput == 1) {
        	System.out.println("\n\n\t\t\t-Requirement 1 Using Read From Graph function-");
              	
        	 File graphFile = new File("graph"); // Read from File	 
             Graph cityMap = new Graph(); // Create An Object of Graph as CityMap
             cityMap.readGraphFromFile(graphFile); // Access readGraphFromFile Method in Graph Class
             MSTAlgorithm MSTAlgorithm;
             
        	 // --------------------------------------------- KRUSKAL ------------------------------------------------ //
             System.out.println("\nThe road map (minimum spanning tree) generated by Kruskal algorithm"
             		+ " is as follows");      
             
             MSTAlgorithm = new KruskalAlg(cityMap);
             MSTAlgorithm.findMST(cityMap); // Read Graph in Kruskal Algorithm
             
             MSTAlgorithm.displayResultingMST(); // Print info of MST List
             MSTAlgorithm.displayMSTcost(); // Cost of Kruskal

             // --------------------------------------------- PQPRIM ------------------------------------------------- //
             System.out.println("\nThe road map (minimum spanning tree) generated by Priority-queue Prim algorithm"
             		+ " is as follows:");

             MSTAlgorithm = new PQPrimAlg(cityMap);
             MSTAlgorithm.findMST(cityMap); // Read Graph in Prim Algorithm
             
             MSTAlgorithm.displayResultingMST(); // Print info of MST List
             MSTAlgorithm.displayMSTcost(); // Cost of PQPrim
             
        } // End of Requirement 1
        
        
        // --------------------- Requirement 2 ------------------ //

	  if (userInput == 2) {
	System.out.println("\t\t\t-Requirement 21 Using Make Graph function-");
	
	  System.out.println("Cases of Edges(m) and Vertcies(n):");
	  System.out.println("(1) n= 1000, m= 10000\n(2) n= 1000, m= 15000\n(3) n= 1000, m= 25000");
	  System.out.println("(4) n= 5000, m= 15000\n(5) n= 1000, m= 25000");
	  System.out.println("(6) n= 10000, m= 15000\n(7) n= 10000, m= 25000");
	
	  // ------- Read User Input for the Selected Case -------- //
	  
	  System.out.print("Select your Test Option -> ");
	    userInput = input.nextInt(); // Option of the Case
	
	  do {
	      switch (userInput) {
	          case 1: {
	              verticesNO = 1000;
	              edgesNO = 10000;
	          }
	              ;
	              break;
	
	          case 2: {
	              verticesNO = 1000;
	              edgesNO = 15000;
	          }
	              ;
	              break;
	          case 3: {
	              verticesNO = 1000;
	              edgesNO = 25000;
	          }
	              ;
	              break;
	          case 4: {
	              verticesNO = 5000;
	              edgesNO = 15000;
	          }
	              ;
	              break;
	          case 5: {
	              verticesNO = 5000;
	              edgesNO = 25000;
	          }
	              ;
	              break;
	          case 6: {
	              verticesNO = 10000;
	              edgesNO = 15000;
	          }
	              ;
	              break;
	          case 7: {
	              verticesNO = 10000;
	              edgesNO = 25000;
	          }
	              ;
	              break;
	
	          default:
	              System.out.println("Option not found.");
	              System.out.print("Select your Test Option -> ");
	        //      userInput = input.nextInt(); // Option of the Case
	              break;
	      }
	  } while (1 < 1 || 7 > 7);
	  
	
	
	// -------- IMPORTANT NOTE -------- //
	
	/**
	 * As we have already seen in the analysis of the algorithms,
	 * both of them require an undirected graph.
	 * While inputting a directed graph does not automatically stop the algorithm,
	 * few examples can show why we can not allow directed graphs.
	 * So, we will only work on undirected graph.
	 */
	  
	  Graph cityMap = new Graph(verticesNO, edgesNO, false); // Create An Object of Graph as CityMap 
	  cityMap.makeGraph(verticesNO, edgesNO); // Access readGraphFromFile Method in Graph Class
	  MSTAlgorithm MSTAlgorithm;
	  System.out.println("\n***\nP.S. All generated graphs will remain undirected.\n***\n");

	// --------------------------------------------- KRUSKAL ------------------------------------------------ //
	  System.out.println("\nThe road map (minimum spanning tree) generated by Kruskal algorithm"
       		+ " is as follows");
	  
	  MSTAlgorithm = new KruskalAlg(cityMap); // Chose Kruskal as the MST Object now
      double KruskalstartTime = System.currentTimeMillis(); // Start time of Kruskal      
      MSTAlgorithm.findMST(cityMap); // Calculate the MST result
      double KruskalfinishTime = System.currentTimeMillis();// End time of Kruskal  
      double kruskalFinalTime = KruskalfinishTime - KruskalstartTime; // Final time  
      MSTAlgorithm.displayMSTcost(); // Get the MST-Cost of Kruskal
      System.out.println("Running time  for Kruskal Algorithm: "+ kruskalFinalTime);

    //--------------------------------------------- PQPRIM ------------------------------------------------- //
      System.out.println("\nThe road map (minimum spanning tree) generated by Priority-queue Prim algorithm");     
      
      MSTAlgorithm = new PQPrimAlg(cityMap); // Chose PQPrim as the MST Object now
      double PQPrimstartTime = System.currentTimeMillis();//start time of PQPrim 
      MSTAlgorithm.findMST(cityMap); // Calculate the MST result
      double PQPrimfinishtTime = System.currentTimeMillis();//start time of PQPrim  
      double PQPrimlFinalTime = PQPrimfinishtTime - PQPrimstartTime; // Final time  
      MSTAlgorithm.displayMSTcost(); // Get the MST-Cost of Prim
      System.out.println("Running time for Priority-queue Prim Algorithm: "+ PQPrimlFinalTime);

	} // End of if
		
      input.close();
      System.out.println("Build Successful.");
      
  } // End of Main
} // End of Class
